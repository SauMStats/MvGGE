# MvGGE: Multi-Phenotype Joint Testing of Main Genetic and Gene-Environment Interaction Effects
# Complete R Package Implementation

# =============================================================================
# PACKAGE SETUP FILES
# =============================================================================

# DESCRIPTION file content:
# Package: MvGGE
# Type: Package
# Title: Multi-Phenotype Joint Testing of Main Genetic and Gene-Environment Interaction Effects
# Version: 1.0.0
# Authors@R: 
#     person(given = "Saurabh", family = "Mishra", 
#            email = "saurabh.iith.stats@gmail.com", 
#            role = c("aut", "cre"))
#     person(given = "Arunabha", family = "Majumdar", 
#            email = "arun.majum@iith.ac.in", 
#            role = "aut")
# Description: Performs joint multi-phenotype testing for genetic main effects and 
#     gene-environment interactions using MANOVA for continuous phenotypes and GEE 
#     (Generalized Estimating Equations) for binary and mixed phenotypes. The package
#     provides unified testing framework that automatically detects phenotype types
#     and applies appropriate statistical methods.
# License: MIT + file LICENSE
# Encoding: UTF-8
# LazyData: true
# RoxygenNote: 7.2.3
# URL: https://github.com/yourusername/MvGGE
# BugReports: https://github.com/yourusername/MvGGE/issues
# Depends: 
#     R (>= 3.5.0)
# Imports:
#     MASS,
#     stats,
#     utils
# Suggests:
#     testthat (>= 3.0.0),
#     knitr,
#     rmarkdown,
#     ggplot2,
#     dplyr

# NAMESPACE file content:
# Generated by roxygen2: do not edit by hand
# export(test_MvGGE)
# export(simulate_data)
# export(MvGGE_config)
# export(validate_inputs)
# export(adjust_pvalues)
# importFrom(MASS,mvrnorm)
# importFrom(stats,lm)
# importFrom(stats,glm)
# importFrom(stats,anova)
# importFrom(stats,binomial)
# importFrom(stats,gaussian)
# importFrom(stats,cor)
# importFrom(stats,pchisq)
# importFrom(stats,quantile)
# importFrom(stats,residuals)
# importFrom(stats,coef)
# importFrom(stats,model.matrix)
# importFrom(utils,packageVersion)

#' @title MvGGE: Multi-Phenotype Joint Testing Package
#' @description
#' This package performs joint multi-phenotype testing for genetic main effects
#' and gene-environment interactions. It supports continuous, binary, and mixed
#' phenotype combinations using appropriate statistical methods (MANOVA, GEE).
#' 
#' @details
#' The package provides three main analysis types:
#' \itemize{
#'   \item Continuous-Continuous: Uses MANOVA with Wilks' lambda test
#'   \item Binary-Binary: Uses bivariate GEE with Wald test
#'   \item Mixed (Continuous-Binary): Uses mixed GEE with Wald test
#' }
#' 
#' @author 
#' Saurabh Mishra \email{saurabh.iith.stats@gmail.com}
#' 
#' Arunabha Majumdar \email{arun.majum@iith.ac.in}
#' 
#' @references
#' Mishra, S. & Majumdar, A. (2024). MvGGE: Multi-Phenotype Joint Testing of
#' Main Genetic and Gene-Environment Interaction Effects.
#' 
#' @keywords internal
"_PACKAGE"

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

#' Configuration for MvGGE Analysis
#' 
#' @description
#' Creates a configuration object for MvGGE analysis with customizable parameters.
#' 
#' @param max_iterations Maximum number of iterations for GEE convergence (default: 100)
#' @param convergence_threshold Threshold for convergence (default: 1e-7)
#' @param regularization_epsilon Regularization parameter for matrix inversion (default: 1e-8)
#' @param verbose Logical, whether to print progress messages (default: FALSE)
#' 
#' @return A list with class 'MvGGE_config' containing configuration parameters
#' 
#' @examples
#' # Default configuration
#' config <- MvGGE_config()
#' 
#' # Custom configuration
#' config <- MvGGE_config(max_iterations = 200, verbose = TRUE)
#' 
#' @export
MvGGE_config <- function(max_iterations = 100,
                         convergence_threshold = 1e-7,
                         regularization_epsilon = 1e-8,
                         verbose = FALSE) {
  
  # Input validation
  if (!is.numeric(max_iterations) || max_iterations <= 0) {
    stop("max_iterations must be a positive integer")
  }
  if (!is.numeric(convergence_threshold) || convergence_threshold <= 0) {
    stop("convergence_threshold must be a positive number")
  }
  if (!is.numeric(regularization_epsilon) || regularization_epsilon <= 0) {
    stop("regularization_epsilon must be a positive number")
  }
  if (!is.logical(verbose)) {
    stop("verbose must be TRUE or FALSE")
  }
  
  structure(list(
    max_iterations = as.integer(max_iterations),
    convergence_threshold = convergence_threshold,
    regularization_epsilon = regularization_epsilon,
    verbose = verbose
  ), class = "MvGGE_config")
}

#' Validate Inputs for MvGGE Analysis
#' 
#' @description
#' Comprehensive validation of input data for MvGGE analysis.
#' 
#' @param Y1 Vector for phenotype 1. Can be continuous or binary (0/1).
#' @param Y2 Vector for phenotype 2. Can be continuous or binary (0/1).
#' @param G Vector of genotypes (0, 1, 2 for additive coding).
#' @param E Vector of environmental factors (typically 0/1 for binary exposure).
#' 
#' @return TRUE if all validations pass, otherwise stops with error message
#' 
#' @examples
#' # Valid inputs
#' Y1 <- rnorm(100)
#' Y2 <- rbinom(100, 1, 0.3)
#' G <- sample(0:2, 100, replace = TRUE)
#' E <- rbinom(100, 1, 0.2)
#' validate_inputs(Y1, Y2, G, E)
#' 
#' @export
validate_inputs <- function(Y1, Y2, G, E) {
  
  # Check input types
  if (!is.numeric(Y1)) stop("Y1 must be numeric")
  if (!is.numeric(Y2)) stop("Y2 must be numeric")
  if (!is.numeric(G)) stop("G must be numeric")
  if (!is.numeric(E)) stop("E must be numeric")
  
  # Check dimensions
  n1 <- length(Y1)
  n2 <- length(Y2)
  nG <- length(G)
  nE <- length(E)
  
  if (!all(c(n2, nG, nE) == n1)) {
    stop("All input vectors must have the same length")
  }
  
  # Check for minimum sample size
  if (n1 < 10) {
    warning("Sample size is very small (n < 10). Results may be unreliable.")
  }
  
  # Check for missing values
  missing_Y1 <- sum(is.na(Y1))
  missing_Y2 <- sum(is.na(Y2))
  missing_G <- sum(is.na(G))
  missing_E <- sum(is.na(E))
  
  if (missing_Y1 > 0 || missing_Y2 > 0 || missing_G > 0 || missing_E > 0) {
    warning(sprintf("Missing values detected: Y1=%d, Y2=%d, G=%d, E=%d. Consider imputation or complete case analysis.",
                   missing_Y1, missing_Y2, missing_G, missing_E))
  }
  
  # Remove missing values for further checks
  complete_cases <- complete.cases(Y1, Y2, G, E)
  if (sum(complete_cases) < n1) {
    Y1 <- Y1[complete_cases]
    Y2 <- Y2[complete_cases]
    G <- G[complete_cases]
    E <- E[complete_cases]
    n1 <- length(Y1)
  }
  
  # # Check G coding (should be 0, 1, 2 for additive model)
  # unique_G <- unique(G)
  # if (!all(unique_G %in% 0:2)) {
  #   stop("Genotype G must be coded as 0, 1, or 2 (additive coding)")
  # }
  # 
  # # Check for Hardy-Weinberg proportions (warning only)
  # G_counts <- table(G)
  # if (length(G_counts) == 3) {
  #   n_total <- sum(G_counts)
  #   p <- (G_counts[["1"]] + 2 * G_counts[["2"]]) / (2 * n_total)
  #   expected_HW <- c((1-p)^2, 2*p*(1-p), p^2) * n_total
  #   names(expected_HW) <- c("0", "1", "2")
  #   
  #   # Chi-square test for HWE
  #   if (all(expected_HW >= 5)) {
  #     hwe_chi2 <- sum((G_counts - expected_HW)^2 / expected_HW)
  #     hwe_p <- pchisq(hwe_chi2, df = 1, lower.tail = FALSE)
  #     if (hwe_p < 0.05) {
  #       warning("Genotype frequencies deviate significantly from Hardy-Weinberg equilibrium (p = ", 
  #              round(hwe_p, 4), ")")
  #     }
  #   }
  # }
  # 
  # Check binary phenotypes coding
  is_Y1_binary <- length(unique(Y1)) <= 2 && all(unique(Y1) %in% c(0, 1))
  is_Y2_binary <- length(unique(Y2)) <= 2 && all(unique(Y2) %in% c(0, 1))
  
  if (is_Y1_binary && !all(Y1 %in% c(0, 1))) {
    stop("Binary phenotype Y1 must be coded as 0 or 1")
  }
  if (is_Y2_binary && !all(Y2 %in% c(0, 1))) {
    stop("Binary phenotype Y2 must be coded as 0 or 1")
  }
  
  # Check for sufficient variation
  if (var(Y1, na.rm = TRUE) == 0) {
    stop("Y1 has zero variance")
  }
  if (var(Y2, na.rm = TRUE) == 0) {
    stop("Y2 has zero variance")
  }
  if (var(G, na.rm = TRUE) == 0) {
    warning("G has zero variance (monomorphic)")
  }
  
  # Check minor allele frequency
  if (var(G, na.rm = TRUE) > 0) {
    maf <- min(mean(G, na.rm = TRUE) / 2, 1 - mean(G, na.rm = TRUE) / 2)
    if (maf < 0.01) {
      warning("Very low minor allele frequency (MAF = ", round(maf, 4), "). Results may be unreliable.")
    }
  }
  
  return(TRUE)
}

#' Check if Variable is Binary
#' 
#' @description
#' Helper function to determine if a variable is likely binary (0/1 coding).
#' 
#' @param y Numeric vector to check
#' 
#' @return Logical indicating if y appears to be binary
#' 
#' @keywords internal
is_binary <- function(y) {
  if (!is.numeric(y)) return(FALSE)
  unique_vals <- unique(y[!is.na(y)])
  return(length(unique_vals) <= 2 && all(unique_vals %in% c(0, 1)))
}

#' Safe Matrix Inversion with Regularization
#' 
#' @description
#' Performs matrix inversion with regularization to handle near-singular matrices.
#' 
#' @param mat Matrix to invert
#' @param epsilon Regularization parameter (default: 1e-8)
#' 
#' @return Inverted matrix
#' 
#' @keywords internal
safe_solve <- function(mat, epsilon = 1e-8) {
  if (!is.matrix(mat)) mat <- as.matrix(mat)
  
  # For 2x2 matrices, use direct formula for speed
  if (nrow(mat) == 2 && ncol(mat) == 2) {
    return(fast_2x2_inverse(mat, epsilon))
  }
  
  # General case
  result <- tryCatch({
    solve(mat)
  }, error = function(e) {
    # Try with regularization
    tryCatch({
      solve(mat + epsilon * diag(nrow(mat)))
    }, error = function(e2) {
      warning("Matrix inversion failed even with regularization. Using pseudoinverse.")
      # Fallback to diagonal approximation
      diag_vals <- diag(mat)
      diag_vals[diag_vals == 0] <- epsilon
      diag(1 / diag_vals)
    })
  })
  
  return(result)
}

#' Fast 2x2 Matrix Inverse
#' 
#' @description
#' Optimized inversion for 2x2 matrices using direct formula.
#' 
#' @param mat 2x2 matrix to invert
#' @param epsilon Regularization parameter
#' 
#' @return Inverted 2x2 matrix
#' 
#' @keywords internal
fast_2x2_inverse <- function(mat, epsilon = 1e-8) {
  a <- mat[1,1]; b <- mat[1,2]; c <- mat[2,1]; d <- mat[2,2]
  det_val <- a*d - b*c
  
  if (abs(det_val) < epsilon) {
    # Add regularization to diagonal
    a <- a + epsilon
    d <- d + epsilon
    det_val <- a*d - b*c
  }
  
  if (abs(det_val) < epsilon) {
    warning("Matrix is singular even after regularization")
    return(diag(c(1/max(a, epsilon), 1/max(d, epsilon))))
  }
  
  inv_det <- 1/det_val
  matrix(c(d*inv_det, -c*inv_det, -b*inv_det, a*inv_det), 2, 2)
}

#' Expit (Inverse Logit) Function
#' 
#' @description
#' Numerically stable implementation of the expit function.
#' 
#' @param x Numeric vector
#' 
#' @return Vector of probabilities
#' 
#' @keywords internal
expit <- function(x) {
  # Bound x to prevent overflow
  x_bounded <- pmin(pmax(x, -20), 20)
  p <- exp(x_bounded) / (1 + exp(x_bounded))
  # Ensure probabilities are in valid range
  pmin(pmax(p, 1e-10), 1 - 1e-10)
}

# =============================================================================
# CORE ANALYSIS FUNCTIONS
# =============================================================================

#' Compute Joint Multi-Phenotype P-Value for Continuous Phenotypes
#'
#' @description
#' Performs MANOVA-based joint testing for continuous phenotypes using Wilks' lambda test.
#'
#' @param Y Matrix of continuous phenotypes (n x m) where m >= 2
#' @param G Vector of genotypes (length n)
#' @param E Vector of environmental factors (length n)
#' @param config MvGGE configuration object
#'
#' @return A list containing test results
#' 
#' @keywords internal
compute_joint_continuous <- function(Y, G, E, config = MvGGE_config()) {
  if (!is.matrix(Y)) Y <- as.matrix(Y)
  m <- ncol(Y)
  n <- nrow(Y)
  GE <- G * E
  
  # Create data frame for analysis
  Data <- data.frame(Y, G = G, E = E, GE = GE)
  colnames(Data)[1:m] <- paste0("Y", 1:m)
  
  # Build formula string
  formula_str <- paste("cbind(", paste(colnames(Data)[1:m], collapse = ", "), ") ~ G + E + GE")
  
  # Fit models
  tryCatch({
    model_full <- lm(as.formula(formula_str), data = Data)
    model_reduced <- update(model_full, . ~ . - G - GE)
    
    # ANOVA test
    anova_result <- anova(model_full, model_reduced, test = "Wilks")
    
    # Extract results
    f_statistic <- anova_result$Wilks[2]
    p_value <- anova_result$`Pr(>F)`[2]
    df1 <- anova_result$Df[2]  # Numerator df
    df2 <- n - ncol(model.matrix(model_full))  # Denominator df
    
    return(list(
      test_type = "F-statistic (Wilks)",
      statistic = f_statistic,
      p_value = p_value,
      df1 = df1,
      df2 = df2,
      method = "MANOVA",
      n_obs = n,
      n_phenotypes = m
    ))
  }, error = function(e) {
    return(list(
      test_type = "F-statistic (Wilks)",
      statistic = NA,
      p_value = NA,
      error = e$message,
      method = "MANOVA",
      n_obs = n,
      n_phenotypes = m
    ))
  })
}

#' GEE Engine for Mixed Phenotypes
#' 
#' @description
#' Core GEE computation for mixed phenotype analysis.
#' 
#' @param parameters Parameter vector
#' @param design_matrix Design matrix
#' @param response_matrix Response matrix
#' @param r Correlation parameter
#' @param phi Scale parameter
#' @param config Configuration object
#' 
#' @return List with GEE results
#' 
#' @keywords internal
GEE_mixed <- function(parameters, design_matrix, response_matrix, r, phi, 
                      config = MvGGE_config()) {
  X <- as.matrix(design_matrix)
  Y <- as.matrix(response_matrix)
  L <- ncol(X)
  n <- nrow(X)
  
  # Split parameters
  beta1 <- parameters[1:L]
  beta2 <- parameters[(L + 1):(2 * L)]
  
  # Compute predictions
  mu1 <- X %*% beta1
  eta2 <- pmin(pmax(X %*% beta2, -20), 20)
  mu2 <- expit(eta2)
  var2 <- pmin(pmax(mu2 * (1 - mu2), 1e-10), 1 - 1e-10)
  
  # Bound parameters
  phi_bounded <- max(phi, config$regularization_epsilon)
  r_bounded <- pmin(pmax(r, -0.99), 0.99)
  
  # Initialize matrices
  B1 <- matrix(0, 2 * L, 1)
  B3 <- matrix(0, 2 * L, 2 * L)
  all_Ui <- matrix(0, 2 * L, n)
  
  # Main computation loop
  for (i in 1:n) {
    # Derivative matrix
    Di <- rbind(c(X[i, ], rep(0, L)), 
                c(rep(0, L), var2[i] * X[i, ]))
    
    # Covariance matrix
    Vi <- matrix(c(phi_bounded^2, 
                   r_bounded * phi_bounded * sqrt(var2[i]),
                   r_bounded * phi_bounded * sqrt(var2[i]), 
                   var2[i]), 2, 2)
    
    V_inv <- safe_solve(Vi, config$regularization_epsilon)
    
    # Residuals
    Yi_mui <- c(Y[i, 1] - mu1[i], Y[i, 2] - mu2[i])
    
    # Score contribution
    Ui <- t(Di) %*% V_inv %*% Yi_mui
    all_Ui[, i] <- Ui
    B1 <- B1 + Ui
    B3 <- B3 + t(Di) %*% V_inv %*% Di
  }
  
  # Covariance matrix
  B2 <- all_Ui %*% t(all_Ui)
  VarCov <- safe_solve(B3, config$regularization_epsilon) %*% B2 %*% 
            safe_solve(B3, config$regularization_epsilon)
  
  list(Usum = B1, InfoMat = B3, UUtSum = B2, VCovMat = VarCov)
}

#' GEE Engine for Binary Phenotypes
#' 
#' @description
#' Core GEE computation for binary phenotype analysis.
#' 
#' @param parameters Parameter vector
#' @param design_matrix Design matrix
#' @param response_matrix Response matrix
#' @param r Correlation parameter
#' @param config Configuration object
#' 
#' @return List with GEE results
#' 
#' @keywords internal
GEE_binary <- function(parameters, design_matrix, response_matrix, r, 
                       config = MvGGE_config()) {
  X <- as.matrix(design_matrix)
  Y <- as.matrix(response_matrix)
  L <- ncol(X)
  n <- nrow(X)
  
  # Split parameters
  beta1 <- parameters[1:L]
  beta2 <- parameters[(L + 1):(2 * L)]
  
  # Compute predictions
  eta1 <- pmin(pmax(X %*% beta1, -20), 20)
  mu1 <- expit(eta1)
  var1 <- pmin(pmax(mu1 * (1 - mu1), 1e-10), 1 - 1e-10)
  
  eta2 <- pmin(pmax(X %*% beta2, -20), 20)
  mu2 <- expit(eta2)
  var2 <- pmin(pmax(mu2 * (1 - mu2), 1e-10), 1 - 1e-10)
  
  # Bound correlation
  r_bounded <- pmin(pmax(r, -0.99), 0.99)
  
  # Initialize matrices
  B1 <- matrix(0, 2 * L, 1)
  B3 <- matrix(0, 2 * L, 2 * L)
  all_Ui <- matrix(0, 2 * L, n)
  
  # Main computation loop
  for (i in 1:n) {
    # Derivative matrix
    Di <- rbind(c(var1[i] * X[i, ], rep(0, L)), 
                c(rep(0, L), var2[i] * X[i, ]))
    
    # Covariance matrix
    cov_i <- r_bounded * sqrt(var1[i]) * sqrt(var2[i])
    Vi <- matrix(c(var1[i], cov_i, cov_i, var2[i]), 2, 2)
    
    V_inv <- safe_solve(Vi, config$regularization_epsilon)
    
    # Residuals
    Yi_mui <- c(Y[i, 1] - mu1[i], Y[i, 2] - mu2[i])
    
    # Score contribution
    Ui <- t(Di) %*% V_inv %*% Yi_mui
    all_Ui[, i] <- Ui
    B1 <- B1 + Ui
    B3 <- B3 + t(Di) %*% V_inv %*% Di
  }
  
  # Covariance matrix
  B2 <- all_Ui %*% t(all_Ui)
  VarCov <- safe_solve(B3, config$regularization_epsilon) %*% B2 %*% 
            safe_solve(B3, config$regularization_epsilon)
  
  list(Usum = B1, InfoMat = B3, UUtSum = B2, VCovMat = VarCov)
}

#' Compute Joint P-Value for Mixed Phenotypes
#'
#' @description
#' Performs GEE-based joint testing for mixed phenotypes (continuous Y1, binary Y2).
#'
#' @param Y1 Continuous phenotype vector
#' @param Y2 Binary phenotype vector (0/1)
#' @param G Genotype vector (0/1/2)
#' @param E Environment vector
#' @param config Configuration object
#'
#' @return List containing test results
#' 
#' @keywords internal
compute_joint_mixed <- function(Y1, Y2, G, E, config = MvGGE_config()) {
  n <- length(Y1)
  Data <- data.frame(Y1 = Y1, Y2 = Y2, G = G, E = E, GE = G * E)
  pheno <- as.matrix(Data[, 1:2])
  X <- model.matrix(~ G + E + GE, data = Data)
  
  # Fit initial models for starting values
  tryCatch({
    model1 <- glm(Y1 ~ G + E + GE, data = Data, family = "gaussian")
  }, error = function(e) {
    model1 <- glm(Y1 ~ 1, data = Data, family = "gaussian")
  }) -> model1
  
  tryCatch({
    model2 <- glm(Y2 ~ G + E + GE, data = Data, family = "binomial")
  }, error = function(e) {
    model2 <- glm(Y2 ~ 1, data = Data, family = "binomial")
  }) -> model2
  
  # Initialize parameters
  num_params <- ncol(X)
  coef1 <- rep(0, num_params)
  names(coef1) <- colnames(X)
  coef1_init <- coef(model1)
  coef1[names(coef1_init)] <- coef1_init
  
  coef2 <- rep(0, num_params)
  names(coef2) <- colnames(X)
  coef2_init <- coef(model2)
  coef2[names(coef2_init)] <- coef2_init
  
  # Initialize correlation parameters
  pearson_resid1 <- residuals(model1, type = "pearson")
  pearson_resid2 <- residuals(model2, type = "pearson")
  phi <- sqrt(sum(pearson_resid1^2, na.rm = TRUE) / (n - length(coef(model1))))
  r <- cor(pearson_resid1, pearson_resid2, use = "complete.obs")
  r <- pmin(pmax(r, -0.99), 0.99)
  
  # Iterative estimation
  beta_old <- as.vector(c(coef1, coef2))
  k <- length(beta_old)
  
  for (iter in 1:config$max_iterations) {
    if (config$verbose && iter %% 10 == 0) {
      message("GEE iteration: ", iter)
    }
    
    beta_previous <- beta_old
    
    # GEE step
    GEE_result <- GEE_mixed(beta_old, X, pheno, r, phi, config)
    
    # Update parameters
    beta_new <- tryCatch({
      beta_old + as.vector(safe_solve(GEE_result$InfoMat, config$regularization_epsilon) %*% GEE_result$Usum)
    }, error = function(e) beta_old)
    
    # Check for invalid updates
    if (any(is.na(beta_new)) || any(is.infinite(beta_new))) {
      return(list(
        test_type = "Wald Chi-Square",
        statistic = NA,
        p_value = NA,
        error = "Parameter estimation failed",
        method = "GEE-Mixed",
        n_obs = n,
        iterations = iter
      ))
    }
    
    # Check convergence
    diff_squared <- sum((beta_new - beta_previous)^2, na.rm = TRUE)
    if (diff_squared / k <= config$convergence_threshold) {
      if (config$verbose) message("Converged after ", iter, " iterations")
      break
    }
    
    # Update correlation parameters
    lp1 <- X %*% beta_new[1:(k/2)]
    pred_prob <- expit(X %*% beta_new[(k/2 + 1):k])
    
    pearson_resid1 <- pheno[, 1] - lp1
    pearson_resid2 <- (pheno[, 2] - pred_prob) / sqrt(pmax(pred_prob * (1 - pred_prob), 1e-10))
    
    phi <- sqrt(sum(pearson_resid1^2, na.rm = TRUE) / (n - k/2))
    r <- cor(pearson_resid1, pearson_resid2, use = "complete.obs")
    r <- pmin(pmax(r, -0.99), 0.99)
    
    beta_old <- beta_new
  }
  
  # Wald test for G and GE effects
  indices <- c(2, 4, k/2 + 2, k/2 + 4)  # G and GE for both phenotypes
  
  tryCatch({
    VarCov_subset <- GEE_result$VCovMat[indices, indices]
    beta_subset <- beta_new[indices]
    
    wald_statistic <- t(beta_subset) %*% safe_solve(VarCov_subset, config$regularization_epsilon) %*% beta_subset
    p_value <- pchisq(wald_statistic, df = length(indices), lower.tail = FALSE)
    
    return(list(
      test_type = "Wald Chi-Square",
      statistic = as.numeric(wald_statistic),
      p_value = p_value,
      df = length(indices),
      method = "GEE-Mixed",
      n_obs = n,
      iterations = iter,
      coefficients = beta_new,
      vcov_matrix = GEE_result$VCovMat,
      correlation = r,
      scale = phi
    ))
  }, error = function(e) {
    return(list(
      test_type = "Wald Chi-Square",
      statistic = NA,
      p_value = NA,
      error = e$message,
      method = "GEE-Mixed",
      n_obs = n,
      iterations = iter
    ))
  })
}

#' Compute Joint P-Value for Binary Phenotypes
#'
#' @description
#' Performs GEE-based joint testing for binary phenotypes.
#'
#' @param Y1 Binary phenotype vector (0/1)
#' @param Y2 Binary phenotype vector (0/1)
#' @param G Genotype vector (0/1/2)
#' @param E Environment vector
#' @param config Configuration object
#'
#' @return List containing test results
#' 
#' @keywords internal
compute_joint_binary <- function(Y1, Y2, G, E, config = MvGGE_config()) {
  n <- length(Y1)
  Data <- data.frame(Y1 = Y1, Y2 = Y2, G = G, E = E, GE = G * E)
  pheno <- as.matrix(Data[, 1:2])
  X <- model.matrix(~ G + E + GE, data = Data)
  
  # Fit initial models for starting values
  tryCatch({
    model1 <- glm(Y1 ~ G + E + GE, data = Data, family = "binomial")
  }, error = function(e) {
    model1 <- glm(Y1 ~ 1, data = Data, family = "binomial")
  }) -> model1
  
  tryCatch({
    model2 <- glm(Y2 ~ G + E + GE, data = Data, family = "binomial")
  }, error = function(e) {
    model2 <- glm(Y2 ~ 1, data = Data, family = "binomial")
  }) -> model2
  
  # Initialize parameters
  num_params <- ncol(X)
  coef1 <- rep(0, num_params)
  names(coef1) <- colnames(X)
  coef1_init <- coef(model1)
  coef1[names(coef1_init)] <- coef1_init
  
  coef2 <- rep(0, num_params)
  names(coef2) <- colnames(X)
  coef2_init <- coef(model2)
  coef2[names(coef2_init)] <- coef2_init
  
  # Initialize correlation
  pearson_resid1 <- residuals(model1, type = "pearson")
  pearson_resid2 <- residuals(model2, type = "pearson")
  r <- cor(pearson_resid1, pearson_resid2, use = "complete.obs")
  r <- pmin(pmax(r, -0.99), 0.99)
  
  # Iterative estimation
  beta_old <- as.vector(c(coef1, coef2))
  k <- length(beta_old)
  
  for (iter in 1:config$max_iterations) {
    if (config$verbose && iter %% 10 == 0) {
      message("GEE iteration: ", iter)
    }
    
    beta_previous <- beta_old
    
    # GEE step
    GEE_result <- GEE_binary(beta_old, X, pheno, r, config)
    
    # Update parameters
    beta_new <- tryCatch({
      beta_old + as.vector(safe_solve(GEE_result$InfoMat, config$regularization_epsilon) %*% GEE_result$Usum)
    }, error = function(e) beta_old)
    
    # Check for invalid updates
    if (any(is.na(beta_new)) || any(is.infinite(beta_new))) {
      return(list(
        test_type = "Wald Chi-Square",
        statistic = NA,
        p_value = NA,
        error = "Parameter estimation failed",
        method = "GEE-Binary",
        n_obs = n,
        iterations = iter
      ))
    }
    
    # Check convergence
    diff_squared <- sum((beta_new - beta_previous)^2, na.rm = TRUE)
    if (diff_squared / k <= config$convergence_threshold) {
      if (config$verbose) message("Converged after ", iter, " iterations")
      break
    }
    
    # Update correlation
    pred_prob1 <- expit(X %*% beta_new[1:(k/2)])
    pearson_resid1 <- (pheno[, 1] - pred_prob1) / sqrt(pmax(pred_prob1 * (1 - pred_prob1), 1e-10))
    
    pred_prob2 <- expit(X %*% beta_new[(k/2 + 1):k])
    pearson_resid2 <- (pheno[, 2] - pred_prob2) / sqrt(pmax(pred_prob2 * (1 - pred_prob2), 1e-10))
    
    r <- cor(pearson_resid1, pearson_resid2, use = "complete.obs")
    r <- pmin(pmax(r, -0.99), 0.99)
    
    beta_old <- beta_new
  }
  
  # Wald test for G and GE effects
  indices <- c(2, 4, k/2 + 2, k/2 + 4)  # G and GE for both phenotypes
  
  tryCatch({
    VarCov_subset <- GEE_result$VCovMat[indices, indices]
    beta_subset <- beta_new[indices]
    
    wald_statistic <- t(beta_subset) %*% safe_solve(VarCov_subset, config$regularization_epsilon) %*% beta_subset
    p_value <- pchisq(wald_statistic, df = length(indices), lower.tail = FALSE)
    
    return(list(
      test_type = "Wald Chi-Square",
      statistic = as.numeric(wald_statistic),
      p_value = p_value,
      df = length(indices),
      method = "GEE-Binary",
      n_obs = n,
      iterations = iter,
      coefficients = beta_new,
      vcov_matrix = GEE_result$VCovMat,
      correlation = r
    ))
  }, error = function(e) {
    return(list(
      test_type = "Wald Chi-Square",
      statistic = NA,
      p_value = NA,
      error = e$message,
      method = "GEE-Binary",
      n_obs = n,
      iterations = iter
    ))
  })
}

# =============================================================================
# MAIN TESTING FUNCTION
# =============================================================================

#' Multi-Phenotype Joint Testing for Genetic and Gene-Environment Effects
#'
#' @description
#' Performs joint testing of genetic main effects (G) and gene-environment 
#' interactions (GxE) for two phenotypes. Automatically detects phenotype types
#' and applies appropriate statistical methods.
#'
#' @param Y1 Vector for phenotype 1. Can be continuous or binary (0/1).
#' @param Y2 Vector for phenotype 2. Can be continuous or binary (0/1).
#' @param G Vector of genotypes coded as 0, 1, 2 (additive coding).
#' @param E Vector of environmental factors (typically 0/1 for binary exposure).
#' @param config Configuration object created by \code{\link{MvGGE_config}}. 
#'   If NULL, default configuration is used.
#'
#' @return A list with class 'MvGGE_result' containing:
#' \describe{
#'   \item{analysis_type}{Character string describing the analysis performed}
#'   \item{results}{List containing statistical test results}
#'   \item{call}{The function call}
#' }
#'
#' @details
#' The function automatically determines the appropriate analysis based on 
#' phenotype types:
#' \itemize{
#'   \item \strong{Continuous-Continuous}: Uses MANOVA with Wilks' lambda test
#'   \item \strong{Binary-Binary}: Uses bivariate GEE with Wald test  
#'   \item \strong{Mixed}: Uses GEE for mixed phenotypes with Wald test
#' }
#' 
#' Binary phenotypes are automatically detected as variables with only 0 and 1 values.
#' 
#' The joint test examines the null hypothesis:
#' \deqn{H_0: \beta_{G1} = \beta_{GE1} = \beta_{G2} = \beta_{GE2} = 0}
#' where subscripts 1 and 2 refer to phenotypes 1 and 2, respectively.
#'
#' @examples
#' # Simulate example data
#' set.seed(123)
#' data <- simulate_data(n = 500, maf = 0.3, f = 0.2)
#' 
#' # Test continuous phenotypes
#' result1 <- test_MvGGE(data$Y1, data$Y2, data$G, data$E)
#' print(result1)
#' 
#' # Test binary phenotypes  
#' result2 <- test_MvGGE(data$Yb1, data$Yb2, data$G, data$E)
#' print(result2)
#' 
#' # Test mixed phenotypes
#' result3 <- test_MvGGE(data$Y1, data$Yb2, data$G, data$E)
#' print(result3)
#' 
#' # With custom configuration
#' config <- MvGGE_config(verbose = TRUE, max_iterations = 200)
#' result4 <- test_MvGGE(data$Y1, data$Y2, data$G, data$E, config = config)
#'
#' @seealso \code{\link{simulate_data}}, \code{\link{MvGGE_config}}
#' 
#' @references
#' Mishra, S. & Majumdar, A. (2024). MvGGE: Multi-Phenotype Joint Testing of
#' Main Genetic and Gene-Environment Interaction Effects.
#' 
#' @export
test_MvGGE <- function(Y1, Y2, G, E, config = NULL) {
  
  # Store the function call
  call_info <- match.call()
  
  # Use default config if not provided
  if (is.null(config)) {
    config <- MvGGE_config()
  }
  
  # Validate all inputs
  validate_inputs(Y1, Y2, G, E)
  
  # Remove missing values
  complete_cases <- complete.cases(Y1, Y2, G, E)
  if (sum(complete_cases) < length(Y1)) {
    if (config$verbose) {
      message("Removing ", length(Y1) - sum(complete_cases), " observations with missing values")
    }
    Y1 <- Y1[complete_cases]
    Y2 <- Y2[complete_cases]
    G <- G[complete_cases]
    E <- E[complete_cases]
  }
  
  # Check final sample size
  n <- length(Y1)
  if (n < 20) {
    warning("Very small sample size (n = ", n, "). Results may be unreliable.")
  }
  
  # Determine phenotype types
  is_y1_binary <- is_binary(Y1)
  is_y2_binary <- is_binary(Y2)
  
  if (config$verbose) {
    message("Detected phenotypes: Y1 = ", 
           ifelse(is_y1_binary, "binary", "continuous"),
           ", Y2 = ", 
           ifelse(is_y2_binary, "binary", "continuous"))
  }
  
  # Dispatch to appropriate analysis
  if (!is_y1_binary && !is_y2_binary) {
    # Case 1: Continuous - Continuous
    analysis_type <- "Continuous Bivariate (MANOVA)"
    if (config$verbose) message("Performing MANOVA analysis...")
    
    results <- tryCatch({
      Y_matrix <- cbind(Y1, Y2)
      compute_joint_continuous(Y_matrix, G, E, config)
    }, error = function(e) {
      list(
        test_type = "F-statistic (Wilks)",
        statistic = NA,
        p_value = NA,
        error = e$message,
        method = "MANOVA",
        n_obs = n
      )
    })
    
  } else if (is_y1_binary && is_y2_binary) {
    # Case 2: Binary - Binary
    analysis_type <- "Binary Bivariate (GEE)"
    if (config$verbose) message("Performing bivariate binary GEE analysis...")
    
    results <- tryCatch({
      compute_joint_binary(Y1, Y2, G, E, config)
    }, error = function(e) {
      list(
        test_type = "Wald Chi-Square",
        statistic = NA,
        p_value = NA,
        error = e$message,
        method = "GEE-Binary",
        n_obs = n
      )
    })
    
  } else {
    # Case 3: Mixed Phenotypes
    if (!is_y1_binary && is_y2_binary) {
      analysis_type <- "Mixed (Y1 Continuous, Y2 Binary)"
      if (config$verbose) message("Performing mixed phenotype GEE analysis (Y1 continuous, Y2 binary)...")
      
      results <- tryCatch({
        compute_joint_mixed(Y1, Y2, G, E, config)
      }, error = function(e) {
        list(
          test_type = "Wald Chi-Square",
          statistic = NA,
          p_value = NA,
          error = e$message,
          method = "GEE-Mixed",
          n_obs = n
        )
      })
    } else {
      # Y1 binary, Y2 continuous - swap inputs
      analysis_type <- "Mixed (Y1 Binary, Y2 Continuous)"
      if (config$verbose) {
        message("Detected Y1 as binary and Y2 as continuous. Swapping inputs for mixed model.")
        message("Performing mixed phenotype GEE analysis...")
      }
      
      results <- tryCatch({
        # Swap Y1 and Y2 for mixed model (expects continuous first)
        result_swapped <- compute_joint_mixed(Y2, Y1, G, E, config)
        # Add note about swapping
        result_swapped$note <- "Y1 and Y2 were swapped for analysis (mixed model expects continuous phenotype first)"
        result_swapped
      }, error = function(e) {
        list(
          test_type = "Wald Chi-Square",
          statistic = NA,
          p_value = NA,
          error = e$message,
          method = "GEE-Mixed",
          n_obs = n
        )
      })
    }
  }
  
  # Create result object
  result <- structure(list(
    analysis_type = analysis_type,
    results = results,
    call = call_info,
    config = config,
    sample_size = n,
    phenotype_types = list(Y1 = ifelse(is_y1_binary, "binary", "continuous"),
                          Y2 = ifelse(is_y2_binary, "binary", "continuous"))
  ), class = "MvGGE_result")
  
  return(result)
}

# =============================================================================
# SIMULATION FUNCTIONS
# =============================================================================

#' Simulate Data for MvGGE Analysis
#'
#' @description
#' Generates bivariate phenotype data with specified genetic and environmental effects.
#' Creates both continuous and binary versions of phenotypes.
#'
#' @param n Sample size (default: 1000)
#' @param maf Minor allele frequency (default: 0.1)
#' @param f Environmental exposure prevalence (default: 0.1)  
#' @param beta_g Vector of genetic main effects for Y1 and Y2 (default: c(0.1, 0.1))
#' @param beta_e Vector of environmental main effects for Y1 and Y2 (default: c(0.2, 0.2))
#' @param beta_ge Vector of gene-environment interaction effects for Y1 and Y2 (default: c(0.2, 0.2))
#' @param rho Correlation between phenotype errors (default: 0.3)
#' @param tau1 Quantile threshold for binary Y1 (default: 0.7)
#' @param tau2 Quantile threshold for binary Y2 (default: 0.8)
#' @param seed Random seed for reproducibility (default: NULL)
#'
#' @return A list containing:
#' \describe{
#'   \item{Y1, Y2}{Continuous phenotypes}
#'   \item{Yb1, Yb2}{Binary phenotypes (based on quantile thresholds)}
#'   \item{G}{Genotypes (0, 1, 2)}
#'   \item{E}{Environmental exposure (0, 1)}
#'   \item{parameters}{List of simulation parameters used}
#' }
#'
#' @details
#' The simulation model is:
#' \deqn{Y_j = \beta_{g,j} G + \beta_{e,j} E + \beta_{ge,j} G \times E + \epsilon_j}
#' where \eqn{j \in \{1,2\}} indexes the phenotypes and 
#' \eqn{(\epsilon_1, \epsilon_2) \sim MVN(0, \Sigma)} with correlation \eqn{\rho}.
#' 
#' Binary phenotypes are created by thresholding continuous phenotypes at specified quantiles.
#' Genotypes follow Hardy-Weinberg equilibrium with specified minor allele frequency.
#'
#' @examples
#' # Basic simulation
#' data <- simulate_data(n = 1000, maf = 0.3, f = 0.2)
#' utils::head(data.frame(data[1:6]))
#' 
#' # Simulation with strong effects
#' data_strong <- simulate_data(
#'   n = 500,
#'   beta_g = c(0.3, 0.3), 
#'   beta_ge = c(0.4, 0.4),
#'   rho = 0.6
#' )
#' 
#' # Test the simulated data
#' result <- test_MvGGE(data_strong$Y1, data_strong$Y2, data_strong$G, data_strong$E)
#' print(result)
#'
#' @seealso \code{\link{test_MvGGE}}
#' 
#' @importFrom MASS mvrnorm
#' @importFrom stats anova as.formula coef complete.cases cor glm lm 
#'     model.matrix p.adjust pchisq pnorm residuals rbinom quantile update var
#' 
#' @export
simulate_data <- function(n = 1000, 
                         maf = 0.1, 
                         f = 0.1,
                         beta_g = c(0.1, 0.1), 
                         beta_e = c(0.2, 0.2),
                         beta_ge = c(0.2, 0.2), 
                         rho = 0.3,
                         tau1 = 0.7, 
                         tau2 = 0.8,
                         seed = NULL) {
  
  # Input validation
  if (!is.numeric(n) || n <= 0) stop("n must be a positive integer")
  if (!is.numeric(maf) || maf <= 0 || maf >= 0.5) stop("maf must be between 0 and 0.5")
  if (!is.numeric(f) || f <= 0 || f >= 1) stop("f must be between 0 and 1")
  if (!is.numeric(beta_g) || length(beta_g) != 2) stop("beta_g must be a numeric vector of length 2")
  if (!is.numeric(beta_e) || length(beta_e) != 2) stop("beta_e must be a numeric vector of length 2")
  if (!is.numeric(beta_ge) || length(beta_ge) != 2) stop("beta_ge must be a numeric vector of length 2")
  if (!is.numeric(rho) || rho < -1 || rho > 1) stop("rho must be between -1 and 1")
  if (!is.numeric(tau1) || tau1 <= 0 || tau1 >= 1) stop("tau1 must be between 0 and 1")
  if (!is.numeric(tau2) || tau2 <= 0 || tau2 >= 1) stop("tau2 must be between 0 and 1")
  
  # Set seed if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # Generate genotypes (Hardy-Weinberg equilibrium)
  p <- maf
  G_prob <- c((1-p)^2, 2*p*(1-p), p^2)
  G <- sample(0:2, n, replace = TRUE, prob = G_prob)
  
  # Generate environmental exposure
  E <- rbinom(n, 1, f)
  
  # Error correlation matrix
  Sigma <- matrix(c(1, rho, rho, 1), 2, 2)
  
  # Generate correlated errors
  errors <- MASS::mvrnorm(n, mu = rep(0, 2), Sigma = Sigma)
  
  # Compute means for each individual and phenotype
  means <- outer(G, beta_g) + outer(E, beta_e) + outer(G * E, beta_ge)
  
  # Generate continuous phenotypes
  Y_latent <- means + errors
  Y1 <- Y_latent[, 1]
  Y2 <- Y_latent[, 2]
  
  # Generate binary phenotypes based on quantile thresholds
  Yb1 <- as.integer(Y1 > quantile(Y1, tau1, na.rm = TRUE))
  Yb2 <- as.integer(Y2 > quantile(Y2, tau2, na.rm = TRUE))
  
  # Store parameters
  parameters <- list(
    n = n,
    maf = maf,
    f = f,
    beta_g = beta_g,
    beta_e = beta_e,
    beta_ge = beta_ge,
    rho = rho,
    tau1 = tau1,
    tau2 = tau2,
    seed = seed,
    actual_maf = min(mean(G)/2, 1 - mean(G)/2),
    actual_f = mean(E),
    actual_rho = cor(Y1, Y2)
  )
  
  # Return results
  structure(list(
    Y1 = Y1,
    Y2 = Y2,
    Yb1 = Yb1,
    Yb2 = Yb2,
    G = G,
    E = E,
    parameters = parameters
  ), class = "MvGGE_simdata")
}

# =============================================================================
# UTILITY AND POST-PROCESSING FUNCTIONS  
# =============================================================================

#' Adjust P-values for Multiple Testing
#'
#' @description
#' Applies multiple testing correction to a list of MvGGE results.
#'
#' @param results_list List of MvGGE_result objects
#' @param method Method for p-value adjustment (default: "BH" for Benjamini-Hochberg)
#'
#' @return List of results with adjusted p-values added
#'
#' @examples
#' # Simulate multiple datasets and test
#' results <- list()
#' for (i in 1:5) {
#'   data <- simulate_data(n = 200, seed = i)
#'   results[[i]] <- test_MvGGE(data$Y1, data$Y2, data$G, data$E)
#' }
#' 
#' # Apply multiple testing correction
#' results_adj <- adjust_pvalues(results)
#' 
#' @export
adjust_pvalues <- function(results_list, method = "BH") {
  
  if (!is.list(results_list)) {
    stop("results_list must be a list of MvGGE_result objects")
  }
  
  # Extract p-values
  pvals <- sapply(results_list, function(x) {
    if (inherits(x, "MvGGE_result") && !is.null(x$results$p_value)) {
      return(x$results$p_value)
    } else {
      return(NA)
    }
  })
  
  # Apply adjustment
  adjusted_pvals <- p.adjust(pvals, method = method)
  
  # Add adjusted p-values to results
  for (i in seq_along(results_list)) {
    if (inherits(results_list[[i]], "MvGGE_result")) {
      results_list[[i]]$results$p_value_adjusted <- adjusted_pvals[i]
      results_list[[i]]$results$adjustment_method <- method
    }
  }
  
  return(results_list)
}

# =============================================================================
# S3 METHODS
# =============================================================================

#' Print Method for MvGGE Results
#' 
#' @param x MvGGE_result object
#' @param digits Number of digits for rounding (default: 4)
#' @param ... Additional arguments (unused)
#' 
#' @return Invisibly returns the input object
#' 
#' @export
print.MvGGE_result <- function(x, digits = 4, ...) {
  cat("MvGGE Analysis Results\n")
  cat("======================\n\n")
  
  cat("Call:\n")
  print(x$call)
  cat("\n")
  
  cat("Analysis Type: ", x$analysis_type, "\n")
  cat("Sample Size: ", x$sample_size, "\n")
  cat("Phenotype Types: Y1 = ", x$phenotype_types$Y1, ", Y2 = ", x$phenotype_types$Y2, "\n\n")
  
  cat("Test Results:\n")
  cat("-------------\n")
  cat("Test Statistic: ", x$results$test_type, "\n")
  
  if (!is.na(x$results$statistic)) {
    cat("Statistic Value: ", round(x$results$statistic, digits), "\n")
    
    if (!is.null(x$results$df)) {
      cat("Degrees of Freedom: ", x$results$df, "\n")
    }
    
    cat("P-value: ", format.pval(x$results$p_value, digits = digits), "\n")
    
    if (!is.null(x$results$p_value_adjusted)) {
      cat("Adjusted P-value: ", format.pval(x$results$p_value_adjusted, digits = digits), 
         " (", x$results$adjustment_method, ")\n")
    }
    
    # Significance assessment
    alpha <- 0.05
    pval_to_use <- ifelse(!is.null(x$results$p_value_adjusted), 
                         x$results$p_value_adjusted, x$results$p_value)
    
    cat("\nSignificance: ")
    if (pval_to_use < alpha) {
      cat("*** SIGNIFICANT *** at a = ", alpha, "\n")
    } else {
      cat("Not significant at a = ", alpha, "\n")
    }
    
    # Additional details for GEE methods
    if (x$results$method %in% c("GEE-Mixed", "GEE-Binary")) {
      if (!is.null(x$results$iterations)) {
        cat("\nConvergence: ", x$results$iterations, " iterations\n")
      }
      if (!is.null(x$results$correlation)) {
        cat("Estimated Correlation: ", round(x$results$correlation, digits), "\n")
      }
      if (!is.null(x$results$scale)) {
        cat("Scale Parameter: ", round(x$results$scale, digits), "\n")
      }
    }
    
  } else {
    cat("*** ANALYSIS FAILED ***\n")
    if (!is.null(x$results$error)) {
      cat("Error: ", x$results$error, "\n")
    }
  }
  
  if (!is.null(x$results$note)) {
    cat("\nNote: ", x$results$note, "\n")
  }
  
  cat("\n")
  invisible(x)
}

#' Summary Method for MvGGE Results
#' 
#' @param object MvGGE_result object
#' @param ... Additional arguments (unused)
#' 
#' @return A summary object
#' 
#' @export
summary.MvGGE_result <- function(object, ...) {
  
  # Create summary structure
  summary_obj <- list(
    call = object$call,
    analysis_type = object$analysis_type,
    sample_size = object$sample_size,
    phenotype_types = object$phenotype_types,
    test_statistic = object$results$statistic,
    p_value = object$results$p_value,
    method = object$results$method,
    significant = !is.na(object$results$p_value) && object$results$p_value < 0.05
  )
  
  # Add method-specific information
  if (object$results$method == "MANOVA") {
    summary_obj$df1 <- object$results$df1
    summary_obj$df2 <- object$results$df2
  } else if (object$results$method %in% c("GEE-Mixed", "GEE-Binary")) {
    summary_obj$df <- object$results$df
    summary_obj$iterations <- object$results$iterations
    summary_obj$correlation <- object$results$correlation
    if (!is.null(object$results$scale)) {
      summary_obj$scale <- object$results$scale
    }
  }
  
  class(summary_obj) <- "summary.MvGGE_result"
  return(summary_obj)
}

#' Print Method for MvGGE Summary
#' 
#' @param x summary.MvGGE_result object
#' @param ... Additional arguments (unused)
#' 
#' @return Invisibly returns the input object
#' 
#' @export  
print.summary.MvGGE_result <- function(x, ...) {
  cat("MvGGE Analysis Summary\n")
  cat("======================\n\n")
  
  cat("Analysis:", x$analysis_type, "\n")
  cat("Sample Size:", x$sample_size, "\n")
  cat("Method:", x$method, "\n")
  
  if (!is.na(x$test_statistic)) {
    cat("Test Statistic:", round(x$test_statistic, 4), "\n")
    cat("P-value:", format.pval(x$p_value, digits = 4), "\n")
    cat("Significant:", ifelse(x$significant, "Yes", "No"), "\n")
  } else {
    cat("Analysis failed\n")
  }
  
  invisible(x)
}

#' Print Method for MvGGE Simulation Data
#' 
#' @param x MvGGE_simdata object
#' @param ... Additional arguments (unused)
#' 
#' @return Invisibly returns the input object
#' 
#' @export
print.MvGGE_simdata <- function(x, ...) {
  cat("MvGGE Simulated Data\n")
  cat("====================\n\n")
  
  cat("Sample Size:", x$parameters$n, "\n")
  cat("Minor Allele Frequency:", x$parameters$maf, "(target),", 
      round(x$parameters$actual_maf, 3), "(actual)\n")
  cat("Environmental Exposure:", x$parameters$f, "(target),", 
      round(x$parameters$actual_f, 3), "(actual)\n")
  cat("Phenotype Correlation:", x$parameters$rho, "(target),", 
      round(x$parameters$actual_rho, 3), "(actual)\n\n")
  
  cat("Effect Sizes:\n")
  cat("  Genetic (G):", paste(x$parameters$beta_g, collapse = ", "), "\n")
  cat("  Environmental (E):", paste(x$parameters$beta_e, collapse = ", "), "\n") 
  cat("  Interaction (GxE):", paste(x$parameters$beta_ge, collapse = ", "), "\n\n")
  
  cat("Binary Thresholds: t1 =", x$parameters$tau1, ", t2 =", x$parameters$tau2, "\n\n")
  
  cat("Data Summary:\n")
  print(data.frame(
    Y1 = summary(x$Y1),
    Y2 = summary(x$Y2),
    Yb1 = c(table(x$Yb1), NA, NA),
    Yb2 = c(table(x$Yb2), NA, NA),
    G = c(table(x$G), NA),
    E = c(table(x$E), rep(NA, 4))
  ))
  
  invisible(x)
}

# =============================================================================
# ADDITIONAL HELPER FUNCTIONS
# =============================================================================

#' Extract Coefficients from MvGGE Results
#' 
#' @description
#' Extracts parameter estimates and standard errors from MvGGE results.
#' 
#' @param object MvGGE_result object
#' @param ... Additional arguments (unused)
#' 
#' @return Data frame with coefficients, standard errors, and test statistics
#' 
#' @export
coef.MvGGE_result <- function(object, ...) {
  if (is.null(object$results$coefficients) || is.null(object$results$vcov_matrix)) {
    warning("Coefficient information not available for this analysis type")
    return(NULL)
  }
  
  coefs <- object$results$coefficients
  vcov <- object$results$vcov_matrix
  se <- sqrt(diag(vcov))
  
  # Create coefficient names
  k <- length(coefs)
  coef_names <- c(
    paste0("Y1:", c("(Intercept)", "G", "E", "G:E")),
    paste0("Y2:", c("(Intercept)", "G", "E", "G:E"))
  )[1:k]
  
  result <- data.frame(
    Estimate = coefs,
    Std.Error = se,
    z.value = coefs / se,
    p.value = 2 * pnorm(abs(coefs / se), lower.tail = FALSE),
    row.names = coef_names
  )
  
  return(result)
}

#' Extract Variance-Covariance Matrix
#' 
#' @description
#' Extracts the variance-covariance matrix from MvGGE results.
#' 
#' @param object MvGGE_result object
#' @param ... Additional arguments (unused)
#' 
#' @return Variance-covariance matrix
#' 
#' @export
vcov.MvGGE_result <- function(object, ...) {
  if (is.null(object$results$vcov_matrix)) {
    warning("Variance-covariance matrix not available for this analysis type")
    return(NULL)
  }
  
  return(object$results$vcov_matrix)
}

#' Model Diagnostics for MvGGE Results
#' 
#' @description
#' Performs basic diagnostic checks for MvGGE analysis results.
#' 
#' @param object MvGGE_result object
#' @param ... Additional arguments (unused)
#' 
#' @return List with diagnostic information
#' 
#' @export
diagnostics <- function(object, ...) {
  UseMethod("diagnostics")
}

#' @export
diagnostics.MvGGE_result <- function(object, ...) {
  
  diagnostics_list <- list()
  
  # Basic checks
  diagnostics_list$analysis_successful <- !is.na(object$results$statistic)
  diagnostics_list$sample_size <- object$sample_size
  diagnostics_list$method <- object$results$method
  
  if (!diagnostics_list$analysis_successful) {
    diagnostics_list$error <- object$results$error
    return(diagnostics_list)
  }
  
  # Check for convergence (GEE methods)
  if (object$results$method %in% c("GEE-Mixed", "GEE-Binary")) {
    diagnostics_list$converged <- !is.null(object$results$iterations) && 
                                 object$results$iterations < object$config$max_iterations
    diagnostics_list$iterations <- object$results$iterations
    
    # Check correlation estimate
    if (!is.null(object$results$correlation)) {
      diagnostics_list$correlation_estimate <- object$results$correlation
      diagnostics_list$correlation_reasonable <- abs(object$results$correlation) < 0.95
    }
  }
  
  # Sample size adequacy
  diagnostics_list$adequate_sample_size <- object$sample_size >= 50
  
  # Effect size assessment (if coefficients available)
  if (!is.null(object$results$coefficients)) {
    coef_table <- coef(object)
    if (!is.null(coef_table)) {
      # Check for extremely large coefficients (potential numerical issues)
      diagnostics_list$reasonable_coefficients <- all(abs(coef_table$Estimate) < 10, na.rm = TRUE)
      diagnostics_list$max_coefficient <- max(abs(coef_table$Estimate), na.rm = TRUE)
    }
  }
  
  class(diagnostics_list) <- "MvGGE_diagnostics"
  return(diagnostics_list)
}

#' Print Method for MvGGE Diagnostics
#' 
#' @param x MvGGE_diagnostics object
#' @param ... Additional arguments (unused)
#' 
#' @return Invisibly returns the input object
#' 
#' @export
print.MvGGE_diagnostics <- function(x, ...) {
  cat("MvGGE Model Diagnostics\n")
  cat("=======================\n\n")
  
  cat("Analysis Status: ", ifelse(x$analysis_successful, "Successful", "Failed"), "\n")
  
  if (!x$analysis_successful) {
    if (!is.null(x$error)) {
      cat("Error: ", x$error, "\n")
    }
    return(invisible(x))
  }
  
  cat("Method: ", x$method, "\n")
  cat("Sample Size: ", x$sample_size, " (", 
      ifelse(x$adequate_sample_size, "adequate", "small"), ")\n")
  
  if (!is.null(x$converged)) {
    cat("Convergence: ", ifelse(x$converged, "Yes", "No"), 
        " (", x$iterations, " iterations)\n")
  }
  
  if (!is.null(x$correlation_reasonable)) {
    cat("Correlation Estimate: ", round(x$correlation_estimate, 3), " (",
        ifelse(x$correlation_reasonable, "reasonable", "extreme"), ")\n")
  }
  
  if (!is.null(x$reasonable_coefficients)) {
    cat("Coefficients: ", ifelse(x$reasonable_coefficients, "reasonable", "extreme"),
        " (max |beta| = ", round(x$max_coefficient, 3), ")\n")
  }
  
  # Overall assessment
  cat("\nOverall Assessment: ")
  issues <- c()
  if (!x$adequate_sample_size) issues <- c(issues, "small sample")
  if (!is.null(x$converged) && !x$converged) issues <- c(issues, "non-convergence") 
  if (!is.null(x$correlation_reasonable) && !x$correlation_reasonable) issues <- c(issues, "extreme correlation")
  if (!is.null(x$reasonable_coefficients) && !x$reasonable_coefficients) issues <- c(issues, "extreme coefficients")
  
  if (length(issues) == 0) {
    cat("No major issues detected\n")
  } else {
    cat("Issues detected: ", paste(issues, collapse = ", "), "\n")
  }
  
  invisible(x)
}

# =============================================================================
# EXAMPLE DATA
# =============================================================================

#' Example Dataset for MvGGE Analysis
#'
#' @description
#' A simulated dataset demonstrating the structure needed for MvGGE analysis.
#' 
#' @format A data frame with 500 rows and 6 variables:
#' \describe{
#'   \item{Y1}{Continuous phenotype 1}
#'   \item{Y2}{Continuous phenotype 2}
#'   \item{Yb1}{Binary phenotype 1 (0/1)}
#'   \item{Yb2}{Binary phenotype 2 (0/1)}
#'   \item{G}{Genotype (0/1/2, additive coding)}
#'   \item{E}{Environmental exposure (0/1)}
#' }
#' 
#' @details
#' This dataset was generated using \code{simulate_data()} with moderate effect sizes
#' and correlation. It can be used to test package functionality and learn the analysis workflow.
#' 
#' @examples
#' # Load example data
#' data(example_data)
#' 
#' # Basic analysis
#' result <- test_MvGGE(example_data$Y1, example_data$Y2, 
#'                      example_data$G, example_data$E)
#' print(result)
#' 
#' @source Simulated using MvGGE::simulate_data()
"example_data"

# Generate the example data (this would be included in data/ folder)
# set.seed(12345)
# example_data <- simulate_data(n = 500, maf = 0.25, f = 0.3, 
#                              beta_g = c(0.15, 0.12), 
#                              beta_e = c(0.18, 0.20),
#                              beta_ge = c(0.25, 0.22), 
#                              rho = 0.4)
# example_data <- data.frame(
#   Y1 = example_data$Y1,
#   Y2 = example_data$Y2, 
#   Yb1 = example_data$Yb1,
#   Yb2 = example_data$Yb2,
#   G = example_data$G,
#   E = example_data$E
# )
# usethis::use_data(example_data, overwrite = TRUE)

# =============================================================================
# PACKAGE DOCUMENTATION EXAMPLE
# =============================================================================

# This is a complete R package! To use it:
# 
# 1. Create the package structure:
#    - Create a new directory called "MvGGE"
#    - Save this file as "R/MvGGE.R" 
#    - Create the DESCRIPTION file with the content shown at the top
#    - Create the NAMESPACE file (or use roxygen2 to generate it)
#
# 2. Generate documentation:
#    devtools::document("MvGGE")
#
# 3. Install the package:
#    devtools::install("MvGGE")
#
# 4. Or build and check:
#    devtools::check("MvGGE")
#    devtools::build("MvGGE")

# Example usage after installation:
# library(MvGGE)
# 
# # Simulate data
# data <- simulate_data(n = 1000, maf = 0.3, f = 0.2)
# 
# # Run analysis 
# result <- test_MvGGE(data$Y1, data$Y2, data$G, data$E)
# print(result)
# summary(result)
# diagnostics(result)
#
# # Extract coefficients (for GEE methods)
# coef(result)
# vcov(result)

# =============================================================================
# END OF PACKAGE
# =============================================================================